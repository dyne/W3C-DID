zenchain: 1.0
start: did-update-1-collect-pks.zen
blocks:
  did-update-1-collect-pks.zen:
    zenContent: |-
      Scenario 'eddsa': signature

      Given I have a 'string' named 'id'
      Given I have a 'string dictionary' named 'did_document'
      Given I have a 'eddsa signature'

      When I create the 'string array' named 'dids'
      When I copy 'id' to 'did'
      When I move 'did' in 'dids'

      If 'controller' is found in 'did_document'
      When I pickup from path 'did_document.controller'
      When I move 'controller' in 'dids'
      EndIf
      # i don't know if controller is array or string
      # if string nothing change, otherwise it simply flat the contents
      When I create the flat array of contents in 'dids'

      When I create the 'string array' named 'eddsa_public_keys'
      When I set ':' to ':' as 'string'

      Foreach 'did' in 'flat_array'
      When I create the array by splitting 'did' at ':'
      When I create the copy of element '4' in array 'array'
      When I move 'copy' in 'eddsa_public_keys'
      When I remove 'array'
      EndForeach

      Then print the 'id'
      Then print the 'did_document'
      Then print the 'eddsa_signature'
      Then print the 'eddsa_public_keys'
    keysFile: W3CDIDController/did-update-1-update-redis.keys
    next: did-update-2-checks.zen
  did-update-2-checks.zen:
    zenContent: >-
      Rule caller restroom-mw

      Scenario 'eddsa': signature

      Scenario 'w3c': verifcationMethod


      Given I have a valid redis connection on 'redis://localhost:6379'

      Given I read from redis the data under the key 'id' and save the output
      into 'old_did_document'

      Given I have a 'string dictionary' named 'old_did_document'


      # timestamp in proof

      Given I fetch the local timestamp and store it into 'created'

      Given I have a 'string' named 'created'


      # controller did-document needed for id in proof

      Given I read from redis the data under the keys containing
      'did:dyne:controller:' and save the output into 'controller_did_document'

      Given I have a 'string dictionary' named 'controller_did_document'


      # controller keyring for proof

      Given I am 'Issuer'

      Given I read the content of 'contracts/keyring.json'

      Given I have my 'keyring'


      # constants

      Given I have a 'string dictionary' named 'proof'

      Given I have a 'string' named '@context'


      # data input

      Given I have a 'string' named 'id'

      Given I have a 'string dictionary' named 'did_document'

      Given I have a 'eddsa signature'

      Given I have a 'base58 array' named 'eddsa_public_keys'


      # verify id has not changed 

      When I rename the 'id' to 'old_id'

      When I pickup from path 'did_document.id'

      When I verify 'old_id' is equal to 'id'

      When I remove 'id'

      When I create the json of 'did document'

      # verify signature

      When I set 'signature_test' to 'false' as 'string'

      When I set 'true' to 'true' as 'string'

      Foreach 'pk' in 'eddsa_public_keys'

      If I verify the 'json' has a eddsa signature in 'eddsa_signature' by 'pk'

      When I remove 'signature_test'

      When I set 'signature_test' to 'true' as 'string'

      EndIf

      EndForeach

      When I verify 'signature_test' is equal to 'true'


      # copy of created for the AlsoKnowAs

      When I copy 'created' to 'timestamp'


      # create proof

      When I create the jws signature of 'did document'

      When I move 'jws' in 'proof'

      When I move 'created' in 'proof'

      # proof's verification method

      When I pickup from path 'controller_did_document.didDocument.id'

      When I rename the 'id' to 'verificationMethod'

      When I set '#ecdh_public_key' to '#ecdh_public_key' as 'string'

      When I append '#ecdh_public_key' to 'verificationMethod'

      When I move 'verificationMethod' in 'proof'

      When I move 'proof' in 'did document'


      # needed for did doc redis key

      When I pickup from path 'did_document.id'


      When I create the 'string dictionary' named 'result'

      When I rename 'did_document' to 'didDocument'

      When I move 'didDocument' in 'result'

      When I pickup from path 'old_did_document.didDocumentMetadata'


      # prepare dictionary for AlsoKnowAs

      If 'updated' is found in 'didDocumentMetadata'

      When I pickup from path 'didDocumentMetadata.updated'

      When I remove the 'updated' from 'didDocumentMetadata'

      When I move 'timestamp' in 'updated'

      When I move 'updated' in 'didDocumentMetadata'

      EndIf


      If 'updated' is not found in 'didDocumentMetadata'

      When I create the 'string array' named 'updated'

      When I move 'timestamp' in 'updated'

      When I move 'updated' in 'didDocumentMetadata'

      EndIf


      When I move '@context' in 'result'


      Then print the 'id'

      Then print the 'result'

      Then print the 'keyring'
    keysFile: did-update-2-checks.keys
    next: did-update-3-broadcast.zen
  did-update-3-broadcast.zen:
    zenContent: >+
      Rule unknown ignore


      Scenario 'ethereum': store did on blockchain




      Given I have a valid redis connection on 'redis://localhost:6379'


      Given I read into 'ethereum_nonce' and increment the key named by 'nonce'




      # controller ethereum address


      Given I am 'Issuer'


      Given I have the 'keyring'




      Given I have a ethereum endpoint named 'blockchain'




      Given I have a 'ethereum address' named 'storage contract'


      Given I have a 'gas limit'


      Given I have a 'ethereum nonce'


      Given I have a 'gas price'




      Given I have a 'string dictionary' named 'result'


      Given I have a 'string' named 'id'




      When I pickup from path 'result.didDocument'


      When I create the mpack of 'didDocument'


      When I rename the 'mpack' to 'data'


      When I create the ethereum transaction to 'storage contract'


      When I use the ethereum transaction to store 'data'


      When I create the signed ethereum transaction for chain 'fabt'




      Then print the 'signed ethereum transaction'


      Then print the 'id'


      Then print the 'result'


      Then I ask ethereum to broadcast the 'signed_ethereum_transaction' and
      save the transaction id in 'txid'









    keysFile: did-update-3-broadcast.keys
    next: did-update-4-redis.zen
  did-update-4-redis.zen:
    zenContent: |-
      Rule caller restroom-mw

      Given I have a valid redis connection on 'redis://localhost:6379'
      Given I have a 'string' named 'txid'
      Given I have a 'string dictionary' named 'result'
      Given I have a 'string' named 'id'

      When I pickup from path 'result.didDocumentMetadata'
      When I remove the 'didDocumentMetadata' from 'result'

      If 'txid-updated' is found in 'didDocumentMetadata'
      When I pickup from path 'didDocumentMetadata.txid-updated'
      When I move 'txid' in 'txid-updated'
      When I move 'txid-updated' in 'didDocumentMetadata'
      EndIf

      If 'txid-updated' is not found in 'didDocumentMetadata'
      When I create the 'string array' named 'txid-updated'
      When I move 'txid' in 'txid-updated'
      When I move 'txid-updated' in 'didDocumentMetadata'
      EndIf

      When I move 'didDocumentMetadata' in 'result'

      Then print the 'id'
      Then print the 'result'

      Then I write 'result' into redis under the key named by 'id'
